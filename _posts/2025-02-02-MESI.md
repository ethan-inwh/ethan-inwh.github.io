---
title: "MESI 缓存一致性协议"
description: "MESI 是一种用于多处理器系统的缓存一致性协议，确保缓存中的数据在多个处理器之间保持一致"
author: ethan
date: 2025-02-02 09:34:00 +0800
categories: [Linux]
tags: [Linux]
pin: false
math: true
mermaid: true
---

为了解决 CPU 与内存、I/O设备之间读取速度不一致的问题引入了多级缓存，但同时带了数据不一致的问题，为了解决这种数据不一致性问题，又引入了缓存一致性协议，其中，MESI 协议是其中最著名的一种。
缓存写策略是指在多核处理器系统中，缓存对主存进行写操作时采用的策略。

## **基本策略**

从缓存和内存的更新关系来看，缓存写策略可分为写回（Write Back）和写直达（Write Through），其中：
```plaintext
- 写回：
  - 概念：每次写操作，先写入缓存，但是不直接写入内存，仅当缓存被替换（即失效）时，才将数据写入主存
  - 特性：写操作速度快，减少了对主存的访问次数，但是主存数据和缓存数据可能不一样
- 写直达: 
  - 概念：每次写操作，同时将数据写入缓存和主存
  - 特性：数据一致性良好，但是写操作慢
```
{: .lineno}

从写缓存时各CPU之间的更新策略来看，缓存写策略可分为：写更新（Write Update）、写无效（Write Invalidate），其中：
```plaintext
- 写更新
  - 概念：每次缓存写入值，当前处理器发起一次总线请求，通知其他处理器更新他们的缓存
  - 特性： 其他处理器能够立即获取最新的值，但是每次写操作都需要发起总线请求，会占用总线带宽
- 写无效
  - 概念：每次缓存写入新的值，都将其他处理器缓存中对应的值置位无效。
  - 特性：多次写操作只需要发一次总线事件，第一次写操作已经将其他处理器缓存中对应的缓存行置为无效，之后的写不必要更新状态，这样可以节省总线带宽，当其他处理器需要访问该缓存行时，发现缓存行以无效，必须从主存中重新加载新的数据
```
{: .lineno}

从写缓存时数据是否被加载来看，缓存写策略可分为：写分配（Write Allocate）、写不分配（Not Write Allocate），其中：
```plaintext
- 写分配
  - 概念：当 CPU 尝试写入一个不在缓存中的数据时，先将数据块从主存加载到缓存中，在缓冲中进行写操作
  - 特性：提高缓存命中率，当数据加载到缓存中，后续对同一数据的读写可以直接命中缓存；性能较好，结合写回策略时，减少对主存的访问次数；但是，初始写操作延迟较大，需要先将数据从主存中读取到缓存中；也可能导致缓存污染，对于一些不常用的数据也被加载到缓存中，占用宝贵的缓存空间
- 写不分配
  - 概念：当 CPU 尝试写入一个不在缓存中的数据时，直接将数据写入到主存，不将数据块加载到缓存
  - 优点：避免在不经常访问的数据上浪费缓存空间，性能较差，缓存命中率低
```
{: .lineno}

## **MESI 事件**

![Events](/_posts/2025-02/mesi_event.png){: width="720" height="432" .w-50 .left}
MESI 协议是一个基于失效的缓存一致性协议，是支持写回缓存策略的最常用协议，同时为了解决多个核心之间的数据传播问题，提出了总线嗅探策略，即：所有的读写请求都通过总线广播给所有处理器，然后让各个处理器去嗅探这些请求，再根据本地的状态进行相应。MESI 是 Modified、Exclusive、Shared、Invalid 的简称，它定义了每个缓存行的四种状态。

MESI 每种状态及其对应的监听事件如下：

### *Modified：简写 M，修改*
该状态表示当前缓存行有效，但数据被修改了，和主存中的数据不一致，数据仅存在当前核的缓存中
> 监听事件：如果其他 CPU 核需要读取主存中对应的数据，该缓存行必须先回写到主存，并且状态置为 S。
{: .prompt-tip }

### *Exclusive：简写 E，独占*
该状态表示当前缓存行有效，缓存和内存中的数据一致，数据仅存在当前核的缓存中，即，当前缓存是唯一持有该数据的副本且与主存一致
> 监听事件：缓存行必须监听其他缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要置为 S 状态。如果当前核写数据时，则置为 M 状态。
{: .prompt-tip }

### *Shared：简写 S，共享*
该状态表示当前缓存行有效，缓存和内存中的数据一致，数据存在多个核的缓存中
> 监听事件：缓存行必须监听其他核的缓存使该缓存行无效或者独享该缓存行的请求，并且将该缓存置为 I 状态
{: .prompt-tip }

### *Invalid：简写 I，无效*
该状态表示当前缓存行是无效的
> 监听事件：无
{: .prompt-tip }

## **MESI 中存在的问题和优化策略**
MESI 协议保障了多核 cpu 之间的缓存一致性，但是它本身也存在一些问题，主要时当 cpu 内核数据状态发生变化时，需要通过总线通知并等待其他 cpu 核的响应，接收到响应后再修改自身的 cache line，这对于 cpu 来说太耗时了。为了解决上述问题，引入了 store buffer 和 invalidate queue，对应的架构示意图如下：

![Store_buffer](/_posts/2025-02/mesi_store_buffer.png){: width="522" height="516" .w-75 .normal}

### *Store Buffer*
Store Buffer 位于 CPU 和其缓存之间，当 CPU0 需要写数据时，把需要写的值丢到 Store Buffer 中，然后再去执行其他任务，而无需等待其他 CPU 的响应结果。当其他 CPU 给出了响应结果后，CPU0 再将 Store Buffer 中的数据写入到内存中。当 CPU0 需要读取数据时，优先在 Store Buffer 确认是否有数据，如果有，则返回，如果没有，则从缓存中读取。

### *Invalidate Queue*
当 CPU0 接收到 Invalidate （使无效）的消息后，并不会立即响应，而是将消息存储到 Invalidate Queue 中并立即返回 Invalidate Ack 消息，然后 CPU0 在合适的时机执行 Invalidate 操作。

引入 Store Buffer、Invalidate Queue 机制也带来了一些其他问题，主要有2个：Store Buffer 何时写回内存没有保证、Invalidate Queue 何时执行没有保证。为了解决这些问题，尽可能释放 CPU 的处理能力，引入了“内存屏障”（Memory Barrier）。

内存屏障包括了"写屏障"和"读屏障"，其中写屏障是告诉 CPU，在执行这之后的指令之间需要将 Store Buffer 中保存的指令刷新到内存中；读屏障是告诉 CPU，在执行这之后的任何加载数据指令之前，执行所有已经在 Invalidate Queue 中的失效操作的指令。

不同操作系统有不同的内存屏障的实现，通过在合适的位置调用内存屏障指令，程序人员可以及时的让 CPU 执行 Store Buffer 或者 Invalidate Queue，保障程序的正确性。
Tips: 不同类型的锁，例如：自旋锁，原子锁，互斥锁等等，还有信号量的wait / post，编译器扩展都会自动处理内存屏障，内存也会维护一致性。 

> 本文内容：摘录总结
> 原文作者：青春的三大队
> 原文链接：https://juejin.cn/post/7458154789579915264
> 原文来源：稀土掘金